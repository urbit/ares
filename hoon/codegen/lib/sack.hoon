/-  *noir
/+  *soak
=|  moan=(jar * hone)
|%
++  rout
  |=  [soot=sock form=*]
  ^-  _moan
  =/  moot
    %+  ~(put by *(map @hail toot))  `@hail`1
    :*  soot  |
        `form  ~
        [| ~]  |  ~
    ==
  =/  work=(list @hail)  ~[`@hail`1]
  =/  mite  (~(put in *(set @hail)) `@hail`1)
  |^  ^-  _moan
    ~&  ['wyt moot' ~(wyt by moot)]
    ~&  'raid'
    =>  raid
    ~&  'espy'
    =>  espy
    ~&  'loot'
    =>  loot
    ~&  'ruin'
    =>  ruin
    ~&  'loop'
    ?~(work moan $)
  ++  this  .
  ++  raid
    =/  cork  work
    |-  ^-  _this
    ?~  cork  this
    =*  hail  i.cork
    =/  firm  form:(~(got by moot) hail)
    ?>  ?=(^ firm)
    =*  form  u.firm
    =;  code
      %=  $
          moot
        %+  ~(jab by moot)  hail
        |=  =toot
        toot(norm `code)
      ::
          cork  t.cork
      ==
    |-  ^-  nomm
    ?+  form  [%not 0]  :: invalid nock crashes
        [^ *]
      [%par $(form -.form, hail (peg hail 2)) $(form +.form, hail (peg hail 3))]
    ::
        [%0 axe=@]
      [%not axe.form]
    ::
        [%1 non=*]
      [%one non.form]
    ::
        [%2 sofa=* fora=*]
      :*  %two
          ::  we treat the cell [sofa fora] as axis 6 and the
          ::  hypothetically inlined called formula as axis 7
          ::  so the hypothetical inlining looks like
          ::  [%2 [sofa fora] <called formula>]
          $(form sofa.form, hail (peg hail 12))
          $(form fora.form, hail (peg hail 13))
          hail
      ==
    ::
        [%3 coat=*] 
      [%the $(form coat.form, hail (peg hail 3))]
    ::
        [%4 tome=*]
      [%for $(form tome.form, hail (peg hail 3))]
    ::
        [%5 this=* that=*]
      :*  %ivy
          $(form this.form, hail (peg hail 6))
          $(form that.form, hail (peg hail 7))
      ==
    ::
        [%6 what=* then=* else=*]
      :*  %six
        $(form what.form, hail (peg hail 6))
        $(form then.form, hail (peg hail 14))
        $(form else.form, hail (peg hail 15))
      ==
    ::
        [%7 once=* then=*]
      :*  %eve
        $(form once.form, hail (peg hail 6))
        $(form then.form, hail (peg hail 7))
      ==
    ::
        [%8 pint=* then=*]
      $(form [%7 [pint.form [%0 1]] then.form])
    ::
        [%9 here=@ coil=*]
      $(form [%7 coil.form [%2 [%0 1] [%0 here.form]]])
    ::
        [%10 [here=@ twig=*] tree=*]
      :*  %ten
          here.form
          $(form twig.form, hail (peg hail 13))
          $(form tree.form, hail (peg hail 7))
      ==
    ::
        [%11 hint=@ then=*]
      [%sip hint.form $(form then.form, hail (peg hail 7))]
    ::
        [%11 [hint=@ vice=*] then=*]
      :*  %tip
          hint.form
          $(form vice.form, hail (peg hail 13))
          $(form then.form, hail (peg hail 7))
      ==
    ::
        [%12 rent=* walk=*]
      :*  %elf
          $(form rent.form, hail (peg hail 6))
          $(form walk.form, hail (peg hail 7))
      ==
    ==
  ::  learn/backpropagate battery masks
  ++  espy
    =/  cork  work
    |-  ^-  _this
    ?~  cork  this
    =*  hail  i.cork
    =/  [norm=(unit nomm) rake=cape]
      [norm rake]:(~(got by moot) hail)
    ?>  ?=(^ norm)
    =*  code  u.norm
    =^  soon  moot
      |-  ^-  [cape _moot]
      ?-  -.code
          %par
        =/  [lack=cape rack=cape]  ~(rip ca rake)
        =^  lead  moot  $(code left.code, rake lack)
        =^  reed  moot  $(code rite.code, rake rack)
        [(~(uni ca lead) reed) moot]
      ::
          %not
        ?:  =(0 here.code)  [| moot]
        [(~(pat ca rake) here.code) moot]
      ::
          %one  [[| |] moot]
          %two
        =?  moot  ?!((~(has by moot) rail.code))
          %+  ~(put by moot)  rail.code
          :*  [| ~]  |
              ~  ~
              [| ~]  rake
              `hail
          ==
        =/  [soot=sock fake=cape form=(unit) norm=(unit nomm)]
          [soot rake form norm]:(~(got by moot) rail.code)
        =/  mole=(list hone)  ?~(form ~ (~(get ja moan) u.form))
        |-  ^-  [cape _moot]
          ?^  mole
            ?:  ?&  (~(huge so soot.i.mole) soot)
                    !(~(big ca cape.root.i.mole) rake)
                ==
              [cape.soot.i.mole moot]
            $(mole t.mole)
        =.  moot
          %+  ~(jab by moot)  rail.code
          |=  =toot
          toot(rake rake)
        =?  moot  ?&(?=(^ norm) (~(big ca fake) rake))
          +:^$(hail rail.code, code u.norm, rake rake)
        =/  lake  sake:(~(got by moot) rail.code)
        =^  sake  moot  ^$(rake lake, code cost.code)
        =^  folk  moot  ^$(rake &, code corn.code)
        [(~(uni ca sake) folk) moot]
      ::
          %the
        $(code pell.code, rake |)
      ::
          %for
        $(code mall.code, rake |)
      ::
          %ivy
        =^  lake  moot  $(code this.code, rake |)
        =^  rare  moot  $(code that.code, rake |)
        [(~(uni ca lake) rare) moot]
      ::
          %six
        =^  cake  moot  $(code what.code, rake |)
        =^  lake  moot  $(code then.code)
        =^  rare  moot  $(code else.code)
        [(~(uni ca cake) (~(uni ca lake) rare)) moot]
      ::
          %eve
        =^  rare  moot  $(code then.code)
        $(code once.code, rake rare)
      ::
          %ten
        ?:  =(0 here.code)  [| moot]
        =/  [wipe=cape wine=cape]  (~(awl ca rake) here.code)
        =^  lake  moot  $(code twig.code, rake wipe)
        =^  rare  moot  $(code tree.code, rake wine)
        [(~(uni ca lake) rare) moot]
      ::
          %sip
        $(code then.code)
      ::
          %tip
        =^  lake  moot  $(code vice.code, rake |)
        =^  rare  moot  $(code then.code)
        [(~(uni ca lake) rare) moot]
      ::
          %elf
        =^  lake  moot  $(code rent.code, rake |)
        =^  rare  moot  $(code walk.code, rake |)
        [(~(uni ca lake) rare) moot]
      ==
    =.  moot  
      %+  ~(jab by moot)  hail
      |=(=toot toot(sake soon))
    $(cork t.cork)
  ::  propagate subject knowledge forward
  ++  loot
    =/  cork  work
    |-  ^-  _this
    ?~  cork  this
    =*  hail  i.cork
    =/  [norm=(unit nomm) soot=sock root=sock rake=cape sire=(unit @hail)]
    [norm soot root rake sire]:(~(got by moot) hail)
    ?>  ?=(^ norm)
    =*  code  u.norm
    =/  soda=(list (each nomm toms))  ~[[%& code] [%| %wot]]
    =/  silt=(list sock)  ~[soot]
    =|  salt=(list sock)
    =/  halt=(list @hail)  ~[hail]
    |-  ^-  _this
    ?~  soda  ^$(cork t.cork)
    ?:  ?=(%& -.i.soda)
      =*  cone  p.i.soda
      ?-  -.cone
          %par
        $(soda [[%& left.cone] [%& rite.cone] [%| %par] t.soda])
      ::
          %not
        ~&  here+here.cone
        ?:  =(0 here.cone)  $(soda t.soda, salt [[| ~] salt])
        ?>  ?=(^ silt)
        =/  sand  (~(pull so i.silt) here.cone)
        ?~  sand  ~&  %crash-not  $(soda t.soda, salt [[| ~] salt])
        ~&  %found  $(soda t.soda, salt [u.sand salt])
      ::
          %one
        $(soda t.soda, salt [[& moan.cone] salt])
      ::
          %two
        $(soda [[%& cost.cone] [%& corn.cone] [%| %two rail.cone] t.soda])
      ::
          %the
        $(soda [[%& pell.cone] [%| %the] t.soda])
      ::
          %for
        $(soda [[%& mall.cone] [%| %for] t.soda])
      ::
          %ivy
        $(soda [[%& this.cone] [%& that.cone] [%| %ivy] t.soda])
      ::
          %six
        $(soda [[%& what.cone] [%& then.cone] [%& else.cone] [%| %six] t.soda])
      ::
          %eve
        $(soda [[%& once.cone] [%| %eve] [%& then.cone] [%| %vee] t.soda])
      ::
          %ten
        ?:  =(0 here.cone)  $(soda t.soda, salt [[| ~] salt])
        $(soda [[%& twig.cone] [%& tree.cone] [%| %ten here.cone] t.soda])
      ::
          %sip
        $(soda [[%& then.cone] t.soda])
      ::
          %tip
        $(soda [[%& vice.cone] [%& then.cone] [%| %tip hint.cone] t.soda])
      ::
          %elf
        $(soda [[%& rent.cone] [%& walk.cone] [%| %elf] t.soda])
      ==
    =*  kant  p.i.soda
    ?-  kant
        %par
      ?>  ?=(^ salt)
      ?>  ?=(^ t.salt)
      $(soda t.soda, salt [(~(knit so i.t.salt) i.salt) t.t.salt])
    ::
        %the
      ?>  ?=(^ salt)
      $(soda t.soda, salt [[| ~] t.salt])
    ::
        %for
      ?>  ?=(^ salt)
      $(soda t.soda, salt [[| ~] t.salt])
    ::
        %ivy
      ?>  ?=(^ salt)
      ?>  ?=(^ t.salt)
      $(soda t.soda, salt [[| ~] t.t.salt])
    ::
        %six
      ?>  ?=(^ salt)
      ?>  ?=(^ t.salt)
      ?>  ?=(^ t.t.salt)
      $(soda t.soda, salt [(~(purr so i.t.salt) i.salt) t.t.t.salt])
    ::
        %eve
      ?>  ?=(^ salt)
      $(soda t.soda, salt t.salt, silt [i.salt silt])
    ::
        %vee
      ?>  ?=(^ silt)
      $(soda t.soda, silt t.silt)
    ::
        %elf
      ?>  ?=(^ salt)
      ?>  ?=(^ t.salt)
      $(soda t.soda, salt [[| ~] t.t.salt])
    ::
        %wot
      ?>  ?=(^ halt)
      ?>  ?=(^ salt)
      ?>  ?=(^ silt)
      =.  moot
        (~(jab by moot) i.halt |=(=toot toot(root i.salt)))
      =/  rook  (~(app ca rake) root)
      =/  soap  (~(app ca rake) i.salt)
      ?:  ?&(=(~ t.soda) ?!(=(cape.rook cape.soap)) ?=(^ sire))
        :: stack is empty but we learned more to pass on to our sire
        =/  pate  (~(got by moot) u.sire)
        ?>  ?=(^ norm.pate)
        %=  $
          soda  ~[[%& u.norm.pate] [%| %wot]]
          silt  ~[soot.pate]
          salt  ~
          halt  ~[u.sire]
          root  root.pate
          sire  sire.pate
        ==
      $(soda t.soda, halt t.halt, silt t.silt)
    ::
        [%two *]
      ?>  ?=(^ salt)
      ?>  ?=(^ t.salt)
      =/  [soot=sock sake=cape root=sock form=(unit) noir=(unit nomm) rack=cape]
        [soot sake root form norm rake]:(~(got by moot) rail.kant)
      =/  roan=(unit sock)
        ?:  =(& cape.i.salt) :: equality because a cape can be a cell
          =/  huns  (~(get ja moan) data.i.salt)
          |-  ^-  (unit sock)
          ?~  huns  ~
          ?:  ?&  (~(huge so soot.i.huns) i.t.salt)
                  !(~(big ca cape.root.i.huns) rack)
              ==
            `root.i.huns
          $(huns t.huns)
        ~
      ?^  roan  ~&  %already  $(soda t.soda, salt [u.roan t.t.salt])
      ?.  ?|(?!(=(cape.soot cape.i.t.salt)) ?&(=(& cape.i.salt) =(~ form)))
        ~&  %bored
        $(soda t.soda, salt [root t.t.salt])
      =/  note  ?:(=(& cape.i.salt) `data.i.salt ~)
      ~&  note+note
      ~&  rail+rail.kant
      =?  mite  ?&(?=(^ note) =(~ form))  (~(put in mite) rail.kant)
      =.  moot
        (~(jab by moot) rail.kant |=(=toot toot(soot i.t.salt, form note)))
      ?~  noir  $(soda t.soda, salt [[| ~] t.t.salt])
      %=  $
        soda  [[%& u.noir] [%| %wot] t.soda]
        halt  [rail.kant halt]
        salt  t.t.salt
        silt  [i.t.salt silt]
      ==
    ::
        [%ten *]
      ?>  ?=(^ salt)
      ?>  ?=(^ t.salt)
      =/  dawn  (~(darn so i.salt) here.p.i.soda i.t.salt)
      ?~  dawn  $(soda t.soda, salt [[| ~] t.t.salt])
      $(soda t.soda, salt [u.dawn t.t.salt])
    ::
        [%tip *]
      ?>  ?=(^ salt)
      ?>  ?=(^ t.salt)
      $(soda t.soda, salt [i.salt t.t.salt])
    ==
  ::  recursion detection
  ++  ruin
    =/  mile=(list @hail)  ~(tap in mite)
    =.  work  ~  :: non-recursive direct calls
    =|  slag=(set @hail) :: excluded as finalization roots
    =|  flux=(set @hail) :: possible finalization roots
    =|  kids=(jug @hail @hail) :: immediate callees
    =|  loop=(map @hail @hail) :: recursive call targets
    |-  ^-  _this
    ?^  mile
      =/  mill  i.mile
      =/  [mail=(unit @hail) soot=sock form=(unit) rack=cape]
        [sire soot form rake]:(~(got by moot) mill)
      ?>  ?=(^ form)  :: shouldn't get added to mite unless we know it
      =/  mole  (~(get ja moan) u.form)
      |-  ^-  _this
      ?^  mole
        ?:  ?&  (~(huge so soot.i.mole) soot)
                !(~(big ca cape.root.i.mole) rack)
            ==
          ^$(mile t.mile)
        $(mole t.mole)
      =|  sirs=(list @hail)
      |-  ^-  _this
      ?~  mail
        ?~  sirs :: not actually a call just the entrypoint
          ^^$(mile t.mile, flux (~(put in flux) mill))
        %=  ^^$
          mile  t.mile
          work  [i.mile work]
          slag  (~(gas in slag) [mill sirs])
        ==
      =.  kids  (~(put ju kids) u.mail mill)
      =.  mill  u.mail
      =/  [suit=sock soju=cape firm=(unit) mire=(unit @hail) ruck=cape]
        [soot sake form sire rake]:(~(got by moot) mill)
      ?>  ?=(^ firm)
      ~&  formfirm+=(u.form u.firm)
      ~&  hugeso+(~(huge so (~(app ca soju) suit)) soot)
      ~&  bigca+!(~(big ca ruck) rack)
      ?:  ?&  =(u.form u.firm)
              (~(huge so (~(app ca soju) suit)) soot)
              !(~(big ca ruck) rack)
          ==
        %=  ^^$  :: found a recursive direct call
          mile  t.mile
          slag  (~(gas in slag) sirs)
          flux  (~(put in flux) mill)
          loop  (~(put by loop) i.mile mill)
        ==
      $(sirs [mill sirs], mail mire)
    =.  mite  (~(dif in mite) (~(gas in *(set @hail)) work))
    ~&  flux+~(tap in flux)
    =/  done  ~(tap in (~(dif in flux) slag))
    =|  enod=(list (list @hail))
    |-  ^-  _this
    ~&  done+done
    ?~  done
      ?~  enod  this
      $(done i.enod, enod t.enod)
    ?:  (~(has by loop) i.done)  $(done t.done) :: recursive
    =/  hood  (~(got by moot) i.done)
    :: safe to apply masks because we only use things from moan if
    :: output battery mask and input sock match
    =.  soot.hood  (~(app ca sake.hood) soot.hood)
    =.  root.hood  (~(app ca rake.hood) root.hood)
    =.  moot  (~(put by moot) i.done hood)
    ?>  ?=(^ form.hood)
    ?>  ?=(^ norm.hood)
    =.  moan
      %+  ~(add ja moan)  u.form.hood
      [soot.hood (cook u.norm.hood loop) root.hood]
    =/  next  ~(tap in (~(get ju kids) i.done))
    ?~  next
      $(done t.done)
    $(done t.done, enod [next enod])
  ::  pick out food for nomm
  ++  cook
    |=  [norm=nomm pool=(map @hail @hail)]
    ^-  food
    =|  ices=(map @hail [=sock form=*])
    =/  fore=(list nomm)  ~[norm]
    |-  ^-  food
    ?~  fore  [norm ices]
    ?-  -.i.fore
        %par  $(fore [rite.i.fore left.i.fore t.fore])
        %not  $(fore t.fore)
        %one  $(fore t.fore)
        %two
      =/  roil  (~(gut by pool) rail.i.fore rail.i.fore)
      =/  foot  (~(get by moot) roil)
      ?>  ?=(^ foot)
      =?  ices  ?=(^ form.u.foot)
        %+  ~(put by ices)  rail.i.fore
        [soot u.form]:u.foot
      $(fore [corn.i.fore cost.i.fore t.fore])
    ::
        %the  $(fore [pell.i.fore t.fore])
        %for  $(fore [mall.i.fore t.fore])
        %ivy  $(fore [this.i.fore that.i.fore t.fore])
        %six  $(fore [what.i.fore then.i.fore else.i.fore t.fore])
        %eve  $(fore [once.i.fore then.i.fore t.fore])
        %ten  $(fore [twig.i.fore tree.i.fore t.fore])
        %sip  $(fore [then.i.fore t.fore])
        %tip  $(fore [vice.i.fore then.i.fore t.fore])
        %elf  $(fore [rent.i.fore walk.i.fore t.fore])
    ==
  --
--

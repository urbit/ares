/-  sock
/+  ska
:: XX TODO
:: - write down fast hints in constraints so we can assemble cold state
:: - handle snip hints so we don't analyze through them and just insert
::   "dynamic" calls
:: XX fast hints
::   when encountering a fast hint we can generate a 
=>
|%  :: types
+|  %rain
::  constraint
+$  rain
  $%  [%neat axe=@ sail=@hail]                        :: axis beneath
      [%cons left=@hail rite=@hail]                   :: cons
      [%eats eats=@hail]                              :: generated by 3
      [%meat meat=@hail]                              :: generated by 4
      [%eels left=@hail rite=@hail]                   :: generated by 5
      [%edit axe=@ limb=@hail tree=@hail]             :: generated by edit
      [%both what=@hail then=@hail else=@hail]        :: conditional
      [%call sail=@hail dial=@hail tack=(list fame)]  :: result of a call
      [%hint fake=@hail]                              :: crash-safety dependent
      [%scry rift=@hail past=@hail]                   :: scry
      [%boom ~]                                       :: this causes a crash
      [%bomb mine=@hail]                              :: this depends on a crash
  ==
::  constraint and hypothesis matching
+$  mist  (jar @hail rain)
::  reverse dependencies
+$  muck  (jug @hail @hail)
::  hypotheses
+$  mire  (map @hail boot)
::  indirect calls (map formula var to subject var)
+$  indy  (map @hail @hail)
::  established knowledge to meet constraints
+$  snow  (map @hail sock)
::  set of formula variables
+$  haar  (set @hail)
::  intermediate code table based on subject-formula hail pairs
+$  mitt  (map [@hail @hail] nomm)
::  prefix of a boot: safety information
+$  lace  $?(%safe %risk %boom)
::  abstract stack entry
+$  fame  (jug * @hail)
:: calls
+$  meso  (map [@hail @hail] [salt=@hail tack=fame]
:: set of subject+formula hails already done
+$  dune  (set [@hail @hail])
+|  %nomm
::  Nomm (Nock--)
::   9 is rewritten to 7+2
::   8 is rewritten to 7+autocons+0
+$  nomm
  $%  [%par left=nomm rite=nomm]                        :: autocons
      [%not here=@]                                     :: Nock 0
      [%one mede=*]                                     :: Nock 1
      [%two cost=nomm sail=@hail corn=nomm fain=@hail]  :: Nock 2
      [%the pell=nomm]                                  :: Nock 3
      [%for mall=nomm]                                  :: Nock 4
      [%ivy this=nomm that=nomm]                        :: Nock 5
      [%six what=nomm then=nomm else=nomm]              :: Nock 6
      [%eve once=nomm then=nomm]                        :: Nock 7
      [%ten here=@ twig=nomm tree=nomm]                 :: Nock 10
      [%sip hint=@ then=nomm]                           :: Nock 11 (static)
      [%tip hint=@ vice=nomm then=nomm]                 :: Nock 11 (dynamic)
      [%elf rent=nomm walk=nomm]                        :: "Nock 12"
  ==
--
::  +sift translates nock to nomm and establishes initial dataflow
::  constraints
::
::  +draw pushes hypotheses forward through constraints and discovers
::  direct calls
::
::  +trim pushes battery needs back through constraints
::
::  +knot checks discovered direct calls for recursiveness and enqueues
::  them for analysis if not recursive
::
::  once +knot finds no non-recursive direct calls we are done
::
::  XX need to make sure recorded immediate hypotheses (nock 1) get
::  pushed forward
::  XX need to make sure adding new constraints causes new pushes
::  forward and backward
=|  seam=[=hail =mist =muck =mire =meso =snow =mitt]
|_  bell=(map * (map sock sock))  :: already-analyzed arms
::  push battery needs back through constraints
++  trim  ~|  %todo  !!
::  find other code we need to generate, or confirm
::  all remaining calls are recursive or indirect
++  knot  ~|  %todo  !!
:: push a hypothesis forward through constraints
++  draw
  =<
  =/  meow  mire  :: mire now, for comparison
  |=  sail=@hail
  ^-  _seam
  =/  queu=[fore=(list hail) back=(list hail)]  [~[sail] ~]
  |-  ^-  _seam  :: loop over queu
  ?~  fore.queu
    ?~  back.queu  [meso seam]
    $(queu [(flop back.queu) ~])
  =/  ties  (~(get ja mist.seam) i.fore.queu)
  |-  ^-  [_meso _seam] :: loop over constraints
  ?~  ties
    =/  sulk  (~(get by meow) i.fore.queu)
    =/  milk  (~(get by mire) i.fore.queu)
    ?.  =(sulk milk)
      =/  reps  ~(tap in (~(get ju muck.seam) i.fore.queu))
      ^$(fore.queu t.fore.queue, back.queu (weld reps back.queu))
    ^$(fore.queu t.fore.queu)
  ?-  -.i.ties
      %neat
    =/  soot  (quiz sail.i.ties)
    ?:  ?=(%boom -.soot)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu %boom)
      =.  mist.seam  (~(put by mist.seam) ~[[%bomb sail.i.ties]]) :: overwrite constraint with crash
      $(ties t.ties)
    =/  suck  ?:(?=(%safe -.soot) safe.soot risk.soot)
    =/  salt  (cull:ska axe.i.ties suck)
    ?-  -.salt
        %&
      =^  oops  seam  melt
      =.  mist.seam  (~(add ja mist.seam) oops [%neat crax.salt sail.i.ties])
      =.  mist.seam  (~(add ja mist.seam) oops [%boom ~])
      =.  mist.seam  (~(add ja mist.seam) i.fore.queu [%bomb oops])
      =.  mire.seam  (~(put by mire.seam) oops (mime:ska soot croc.salt))
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    ::
        %|
      =.  mire.seam
        %+  ~(put by mire.seam)
          i.fore.queu
        ?:(saul.salt [%safe rock.salt] [%risk rock.salt])
      $(ties t.ties)
    ==
  ::
      %cons
    =/  loot  (quiz left.i.ties)
    ?:  ?=(%boom -.loot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb left.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  root  (quiz rite.i.ties)
    ?:  ?=(%boom -.root)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb rite.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =.  mire.seam  (~(put by mire.seam) (cobb loot root))
    $(ties t.ties)
  ::
      %eats
    =/  foot  (quiz eats.i.ties)
    ?:  ?=(%boom -.foot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb eats.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =.  mire.seam  (~(put by mire.seam) i.fore.queu (mime:ska foot [%flip ~]))
    $(ties t.ties)
  ::
      %meat
    =/  moot  (quiz meat.i.ties)
    ?:  ?=(%boom -.moot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb meat.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  root  (pile:ska moot)
    ?:  ?=(%boom -.root) :: crash caused by non-atom result
      =.  mist.seam  (~(add ja mist.seam) meat.i.ties [%boom ~])
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb meat.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queue root)
      $(ties t.ties)
    =.  mire.seam  (~(put by mire.seam) i.fore.queu root)
    $(ties t.ties)
  ::
      %eels
    =/  loot  (quiz left.i.ties)
    ?:  ?=(%boom -.loot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb left.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  root  (quiz rite.i.ties)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb rite.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =.  mire.seam
      (~(put by mire.seam) i.fore.queu (mite loot (mime root [%flip ~])))
    $(ties t.ties)
  ::
      %edit
    =/  loot  (quiz limb.i.ties)
    ?:  ?=(%boom -.loot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb limb.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  toot  (quiz tree.i.ties)
    ?:  ?=(%boom -.toot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb tree.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  luck  ?:(?=(%safe -.loot) safe.loot risk.loot)
    =/  tuck  ?:(?=(%safe -.toot) safe.toot risk.toot)
    =/  salt  (warn:ska axe.i.ties luck tuck)
    ?-  -.salt
        %&  :: edit crashes
      =^  oops  seam  melt
      =.  mist.seam  (~(add ja mist.seam) oops [%neat crax.salt tree.i.ties])
      =.  mist.seam  (~(add ja mist.seam) oops [%boom ~])
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb oops]~)
      =.  mire.seam  (~(put by mire.seam) oops (mime toot croc.salt))
      =.  mire.seam  (~(put by mire.seam) i.fore.queue [%boom ~])
      $(ties t.ties)
    ::
      %|
    ?:  saul.salt
      =.  mire.seam
        (~(put by mire.seam) i.fore.queu (mite loot (mime toot rock.salt)))
      $(ties t.ties)
    =.  mire.seam
      (~(put by mire.seam) i.fore.queu [%risk rock.salt])
    $(ties t.ties)
  ::
      %both
    =/  woot  (quiz what.i.ties)
    ?:  ?=(-.woot %boom)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb what.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  toot  (quiz then.i.ties)
    =/  foot  (quiz else.i.ties)
    ?:  ?&(?=(%boom -.toot) ?=(%boom +.toot))
      =.  mist.seam
        %+  ~(put by mist.seam)
          i.fore.queu
        ~[[%bomb then.i.ties] [%bomb else.i.ties]]
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =.  mire.seam  (~(put by mire.seam) i.fore.queu (gnaw:ska toot foot))
    $(ties t.ties)
  ::
      %call
    =/  soot  (quiz sail.i.ties)
    ?:  ?=(%boom -.soot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb sail.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  foot  (quiz dial.i.ties)
    ?:  ?=(%boom -.foot)
      =.  mist.seam  (~(put by mist.seam) i.fore.queu [%bomb dial.i.ties]~)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%boom ~])
      $(ties t.ties)
    =/  soft  ?:(?=(%safe -.foot) safe.foot risk.foot)
    ?.  ?=(%know -.soft)
      =.  mire.seam  (~(put by mire.seam) i.fore.queu [%risk %toss ~])
      $(ties t.ties)
    =.  meso.seam  (~(put by meso.seam) [sail dial]:i.ties [i.fore.queu tack.i.ties])
    =?  mire.seam  ?!((~(has by mire.seam) i.fore.queue))
      (~(put by mire.seam) i.fore.queu (mite soot (mime foot [%risk %toss ~])))
    ~|  %todo  !!
  ==  
  |%
  ++  quiz
    |=  =hail
    ^-  boot
    (~(gut by mire.seam) hail [%risk %toss ~])
  --
::  compile a formula to nomm and record SKA constraints
++  sift
  ::  precondition: dial is the constraint variable of a formula known
  ::  in mire
  ::  XX we need to record immediates as well so that the constraint
  ::  updating step can propagate them
  |=  [tack=fame sail=@hail dial=@hail]
  ^-  [[=nomm hail=@hail] _seam]
  =/  more  (~(got by mire) dial)
  ?<  ?=(-.more %boom)
  =/  moil  (trip more)
  ?<  ?=(~ moil)
  ?>  ?=(%know -.u.moil)
  =/  form  know.u.moil
  ?>  ?=(^ tack)
  =.  tack  [(~(put ju i.tack) form sail) tack]
  ?+  form  boom
      [fern=^ leaf=*]
    =^  hoof  seam  $(form fern.form)
    =^  toff  seam  $(form leaf.form)
    =^  itch  seam  melt
    =.  mist.seam  (~(add ja mist.seam) itch [%cons hail.hoof hail.toff])
    =.  muck.seam  (~(gas ju muck.seam) ~[[hail.hoof itch] [hail.toff itch]])
    [[[%par nomm.hoof nomm.toff] itch] seam]
  ::
      [%0 axe=@]
    =^  itch  seam  melt
    =.  mist.seam  (~(add ja mist.seam) itch [%neat axe sail])
    =.  muck.seam  (~(put ju muck.seam) [sail itch])
    [[[%not axe] itch] seam]
  ::
      [%1 the=*]
    =^  itch  seam  melt
    =.  mire.seam  (~(put by mire.seam) itch [%know the])
    [[[%one the] itch] seam]
  ::
      [%2 sofa=* fora=*]
    =^  soot  seam  $(form sofa.form)
    =^  foot  seam  $(form fora.form)
    =^  itch  seam  melt
    =.  mist.seam  (~(add ja mist.seam) itch [%call hail.soot hail.foot tack])
    =.  muck.seam  (~(gas ju muck.seam) ~[[hail.soot itch] [hail.foot itch]])
    [[[%two nomm.soot hail.soot nomm.foot hail.foot] itch] seam]
  ::
      [%3 pell=*]
    =^  poof  seam  $(form pell.form)
    =^  itch  seam  melt
    =.  mist.seam  (~(add ja mist.seam) itch [%eats hail.poof])
    =.  muck.seam  (~(put ju muck.seam) [hail.poof itch])
    [[[%the nomm.poof] itch] seam]
  ::
      [%4 numb=*]
    =^  nope  seam  $(form numb.form)
    =^  itch  seam  melt
    =.  mist.seam  (~(add ja mist.seam) itch [%meat hail.nope])
    =.  muck.seam  (~(put ju muck.seam) [hail.nope itch])
    [[[%for nomm.nope] itch] seam]
  ::
      [%5 this=* that=*]
    =^  firm  seam  $(form this.form)
    =^  farm  seam  $(form that.form)
    =^  itch  seam  melt
    =.  mist.seam  (~(add ja mist.seam) itch [%eels hail.firm hail.farm])
    =.  muck.seam  (~(gas ju muck.seam) ~[[hail.firm itch] [hail.farm itch])
    [[[%ivy nomm.firm nomm.farm] itch] seam]
  ::
      [%6 what=* then=* else=*]
    =^  phat  seam  $(form what.form)
    =^  that  seam  $(form then.form)
    =^  felt  seam  $(form else.form)
    =^  itch  seam  melt
    =.  mist.seam
      (~(add ja mist.seam) itch [%both hail.phat hail.that hail.felt])
    =.  muck.seam
      %-  ~(gas ju muck.seam)
      ~[[hail.phat itch] [hail.that itch] [hail.felt itch]]
    [[[%six nomm.phat nomm.that nomm.felt] itch] seam]
  ::
      [%7 what=* then=*]
    =^  this  seam  $(form what.form)
    =^  that  seam  $(form what.form, sail hail.this)
    [[[%eve nomm.this nomm.that] hail.that] seam]
  ::
      [%8 what=* then=*]  $(form [%7 [what.form %0 1] then.form])
      [%9 axe=@ most=*]  $(form [%7 most.form %2 [%0 1] %0 axe])
      [%10 [axe=@ limb=*] stem=*]
    =^  smol  seam  $(form limb.form)
    =^  huge  seam  $(form tree.form)
    =^  itch  seam  melt
    =.  mist.seam
      (~(add ja mist.seam) itch [%edit axe.form hail.smol hail.huge])
    =.  muck.seam  (~(gas ju muck.seam) ~[[hail.smol itch] [hail.huge itch]])
    [[[%ten axe nomm.smol nomm.huge] itch] seam]
  ::
      [%11 tag=@ real=*]
    =^  feel  seam  $(form real.form)
    [[[%sip tag nomm.feel] hail.feel] seam]
  ::
      [%11 [tag=@ fake=*] real=*]
    =^  fall  seam  $(form fake.form)
    =^  feel  seam  $(form real.form)
    =.  mist.seam  (~(add ja mist.seam) hail.feel [%hint hail.fall])
    =.  muck.seam  (~(put ju muck.seam) [hail.fall hail.feel])
    [[[%dip tag nomm.fall nomm.feel] hail.feel] seam]
  ::
      [%12 raft=* past=*]
    =^  rift  seam  $(form raft.form)
    =^  pass  seam  $(form past.form)
    =^  itch  seam  melt
    =.  mist.seam  (~(add ja mist.seam) itch [%scry hail.rift hail.pass])
    =.  muck.seam  (~(gas ju muck.seam) ~[[hail.rift itch] [hail.pass itch]])
    [[[%elf nomm.rift nomm.pass] itch] seam]
  ==
  |%
  ++  melt  `[@hail _seam]`[hail.seam seam(hail .+(hail.seam))]
  ++  boom  ~|  %todo  !!
  --
--
:::::
::++  sack
::  =|  bell=(map [sock *] nomm)
::  |=  [such=sock form=*] 
::  :: state
::  ::   mist - general constraint set
::  ::   muck - reverse dependencies
::  ::   indy - currently indirect calls
::  ::   meso - possible recursion
::  ::   hail - constraint variable generator
::  ::   mitt - code table
::  ::   snow - known-necessary knowledge
::  ::   haar - formulas
::  =/  seam=[=mist =muck =meso =hail =mitt =snow =haar]
::    :*  (~(gas by *mist) ~[[[%hail 0] [such ~]] [[%hail 1] [[%know form] ~]]])
::        *muck
::        *indy
::        *meso
::        [%hail 2]
::        *mist
::        (~(put by *snow) [%hail 1] [%know form])
::    ==
::  :: accumulated downwards
::  =/  sail=hail  [%hail 0]
::  =/  dial=hail  [%hail 1]
::  =/  tack=(list fame)  ~[(~(put ju *fame) [form sail])]
::  ^-  [work=(list [sock *]) bell=_bell]
::  |^
::    ~|  %todo  !!
::  ::  translate to nomm
::  ++  cook
::    ^-  [[=nomm rail=hail =lace] _seam]
::    ?+  form  boom
::        [left=^ rite=*]
::      =^  lest  seam  cook(form left.form)
::      =^  rest  seam  cook(form rite.form)
::      =^  itch  seam  (knit rail.lest rail.rest)
::      :_  seam
::      :*  [%par nomm.left nomm.rite]
::          itch
::          (land lace.lest lace.rest)
::      ==
::    ::
::        [%0 axe=@]
::      =^  [itch=hail safe=lace]  seam  (cull axe.form)
::      [[[%not axe.form] itch safe] seam]
::    ::
::        [%1 non=*]
::      =^  itch  seam  melt
::      =.  mist.seam  (~(put by mist.seam) itch [[%know non.form] ~])
::      [[[%one non] itch %safe] seam]
::    ::
::        [%2 sofa=* fora=*]
::      =^  sine  seam  cook(form sofa.form)
::      =^  fine  seam  cook(form fora.form)
::      =/  corn  hypo:(~(got by mist.seam) rail.fine)
::      ?.  ?=(%know -.corn)
::        ::  indirect case
::        =^  itch  seam  melt
::        =.  mist.seam
::          %:  ~(put by mist.seam)
::              itch
::              [[%toss ~] ~[[%dino rail.sine] [%dino rail.fine]]]
::          ==
::        =.  muck.seam
::          (~(gas ju muck.seam) ~[[rail.sine itch] [rail.fine] itch])
::        =.  indy.seam  (~(put by indy.seam) rail.fine rail.sine)
::        :_  seam
::        :-  [%two nomm.sine rail.sine nomm.fine rail.fine]
::        [itch (lore %risk (land lace.sine lace.fine))]
::      =/  seed  know.corn
::      ?>  ?=(^ tack)
::      =/  ales
::        %-  ~(gas in *(set hail))
::        %+  skim
::          ~(tap in (~(get ju i.tack) seed))
::        |=  ale=hail
::        (nail ale sine)
::      ~|  %todo  !! 
::    ::
::        [%3 pell=*]
::      =^  pest  seam  cook(form pell.form)
::      =^  itch  seam  (fits rail.pest)
::      [[[%the nomm.pest] itch lace.pest] seam]
::    ::
::        [%4 mall=*]
::      =^  pest  seam  cook(form mall.form)
::      =^  [itch=hail lice=lace]  seam  (pile rail.pest)
::      [[[%for nomm.pest] itch (land lace.pest lice)] seam]
::    ::
::        [%5 this=* that=*]
::      =^  thus  seam  cook(form this.form)
::      =^  than  seam  cook(form that.form)
::      =^  itch  seam  (pear rail.thus rail.than)
::      [[[%ivy nomm.thus nomm.than] itch (land lace.thus lace.than)] seam]
::    ::
::        [%6 what=* then=* else=*]
::      =^  when  seam  cook(form what.form)
::      =^  thus  seam  cook(form then.form)
::      =^  even  seam  cook(form else.form)
::      =^  [itch=hail case=lace]  (mous [rail lace]:thus [rail lace]:even)
::      [[[%six nomm.when nomm.thus nomm.even] itch (land lace.when case)] seam]
::    ::
::        [%7 once=* then=*]
::      =^  best  seam  cook(form once.form)
::      =^  rest  seam  cook(form then.form, sail rail.best)
::      [[[%eve nomm.best nomm.rest] rail.rest (land lace.best lace.rest)] seam]
::    ::
::        [%8 pin=^ ouch=*]
::      cook(form [7 [pin 0 1] ouch])
::    ::
::        [%9 axe=* cone=*]
::      cook(form [7 cone 2 [0 1] 0 axe])
::    ::
::        [%10 [axe=@ limb=*] stem=*]
::      =^  smol  seam  cook(form limb)
::      =^  huge  seam  cook(form stem)
::      =^  [salt=hail race=lace]  seam  (warn axe rail.smol rail.huge)
::      :_  seam
::      :+    [%ten axe nomm.smol nomm.huge]
::        salt
::      (land (land lace.smol lace.huge) race)
::    ::
::        [%11 tag=@ than=*]
::      =^  mine  seam  cook(form than.form)
::      [[[%sip tag.form nomm.mine] +.mine] seam]
::    ::
::        [%11 [tag=@ hind=*] than=*]
::      =^  fine  seam  cook(form hind.form)
::      =^  mine  seam  cook(form than.form)
::      ?:  ?=(%boom lace.fine)
::        [[[%dip tag.form nomm.fine nomm.mine] rail.fine %boom] seam]
::      :_  seam
::      [[%dip tag.form nomm.fine nomm.mine] rail.mine (land lace.fine lace.mine)]
::    ::
::        [%12 ref=* pax=*]
::      =^  rind  seam  cook(form ref.form)
::      =^  wind  seam  cook(form pax.form)
::      =^  itch  seam  (look rail.rind rail.wind)
::      [[[%elf nomm.rind nomm.wind] (land lace.rind lace.wind) itch] seam]
::    ==
::  ::  check recursive constraints
::  ++  bake
::    ~|  %todo  !!
::  ::  generate crash for invalid formula
::  ++  boom
::    ~|  %todo  !! :: no need to constrain dial with crash because it will be fixed in the battery anyway
::  ::  check whether high at least as much information as lowe
::  ++  nail
::    |=  [lowe=hail high=hail]
::    ^-  ?
::    =/  lost  (~(get by snow.seam) lowe)
::    =/  lock  ?~  lost  `sock`[%toss ~]  u.lost
::    =/  hock  hypo:(~(got by mist.seam) high)
::    (nail:ska lost hock)
::  ++  look
::    |=  [ref=hail pax=hail]
::    ^-  [hail seam]
::    =^  itch  melt  seam
::    =.  mist.seam
::      (~(put by mist.seam) itch [[%toss ~] ~[[%dino ref] [%dino pax]]])
::    [itch seam]
::  ++  warn
::    |=  [axe=@ limb=hail stem=hail]
::    ^-  [[hail lace] _seam]
::    =^  itch  melt  seam
::    =/  bole
::      %:  warn:ska
::          axe
::          hypo:(~(got by mist.seam) limb)
::          hypo:(~(got by mist.steam) stem)
::      ==
::    ?-  -.bole
::        %&
::      ?:  =(0 crax.bole)
::        =.  mist.seam  (~(put by mist.seam) itch [[%toss ~] [%boom ~]~])
::        [[itch %boom] seam]
::      =^  crap  melt  seam
::      =.  mist.seam  (~(put by mist.seam) itch [[%toss ~] [%bomb crap]~])
::      =.  mist.seam  (~(put by mist.seam) crap [croc.bole [%neat crax stem])
::      [[itch %boom] seam]
::    ::
::        %|  
::      =.  mist.seam
::        (~(put by mist.seam) itch [rock.bole [%edit axe limb stem]~])
::      [[itch ?:(saul.bole %safe %risk)] seam]
::    ==
::  ::  constrain conditional
::  ++  mous
::    |=  [[nail=hail face=lace] [tail=hail mace=lace]]
::    ^-  [[hail lace] _seam]
::    =^  itch  melt  seam
::    ?:  ?=(%boom face)
::      =/  cole  hypo:(~(got by mist.seam) tail)
::      =.  mist.seam  (~(put by mist.seam) itch [cole [%just tail nail]~])
::      [[itch (dare mace)] seam]
::    ?:  ?=(%boom mace)
::      =/  cole  hypo:(~(got by mist.seam) nail)
::      =.  mist.seam  (~(put by mist.seam) itch [cole [%just nail tail~])
::      [[itch (dare face)] seam]
::    =/  cole
::      %:  mous:ska
::          hypo:(~(got by mist.seam) nail)
::          hypo:(~(got by mist.seam) tail)
::      ==
::    =.  mist.seam  (~(put by mist.seam) itch [cole [%both tail nail]~])
::    ?:  ?|(?=(%risk face) ?=(%risk mace))
::      [[itch %risk] seam]
::    [[itch %safe] seam]
::  ::  constrain equality test
::  ++  pear
::    |=  [tail=hail yale=hail]
::    ^-  [hail _seam]
::    =^  itch  seam  melt
::    =/  thus  hypo:(~(got by mist.seam) tail)
::    =/  than  hypo:(~(got by mist.seam) yale)
::    =/  cole  (pear:ska thus than)
::    =.  mist.seam
::      (~(put by mist.seam) itch [cole ~[[%dino tail] [%dino yale]]])
::    [itch seam]
::  ::  constrain increment
::  ++  pile
::    |=  mail=hail
::    ^-  [[hail lace] _seam]
::    =^  itch  seam  melt
::    =/  pony  hypo:(~(got by mist.seam) mail)
::    ?-  -.pony
::        %know
::      ?@  know.pony
::        =.  mist.seam  (~(put by mist.seam) itch [[%dice ~] [%dino mail]~])
::        [[itch %safe] seam]
::      =.  mist.seam
::        %+  ~(jab by mist.seam)  mail
::        |=  =mire
::        mire(must [[%boom ~] must.mire)
::      =.  mist.seam  (~(put by mist.seam) itch [[%toss ~] ~])
::      [[itch %boom] seam]
::    ::
::        %bets
::      =.  mist.seam
::        %+  ~(jab by mist.seam)  mail
::        |=  =mire
::        mire(must [[%boom ~] must.mire)
::      =.  mist.seam  (~(put by mist.seam) itch [[%toss ~] ~])
::      [[itch %boom] seam]
::    ::
::        %dice
::      =.  mist.seam  (~(put by mist.seam) itch [[%dice ~] [%dino mail]~])
::      [[itch %safe] seam]
::    ::
::        %flip
::      =.  mist.seam  (~(put by mist.seam) itch [[%dice ~] [%dino mail]~])
::      [[itch %safe] seam]
::    ::
::        %toss
::      =.  mist.seam  (~(put by mist.seam) itch [[%dice ~] [%dino mail]~])
::      [[itch %risk] seam]
::    ==
::  ::  constrain cell check
::  ++  fits
::    |=  mail=hail
::    ^-  [hail _seam]
::    =^  itch  seam  melt
::    =/  cole  (fits:ska hypo:(~(got by mist.seam) mail))
::    =.  mist.seam  (~(put by mist.seam) itch [cole [%dino mail]~])
::    [itch seam]
::  ::  constrain axis
::  ++  cull
::    |=  axe=@
::    ^-  [[hail lace] _seam]
::    =^  itch  seam  melt
::    =/  bole  (cull:ska @ hypo:(~(got by mist.seam) sail))
::    ?-  -.bole
::        %&
::      ?:  =(0 crax.bole)
::        =.  mist.seam  (~(put by mist.seam) itch [[%toss ~] ~])
::        [[itch %boom] seam]
::      =^  oops  seam  melt
::      =.  mist.seam
::        (~(put by mist.seam) oops [croc.bole ~[[%boom ~] [%neat crax.bole]]])
::      =.  mist.seam  (~(put by mist.seam) itch [[%toss ~] [%bomb oops]~])
::      [[itch %boom] seam]
::    ::
::        %|
::      =.  mist.seam  (~(put by mist.seam) itch [rock.bole [%neat axe]~])
::      [[%itch ?:(saul.bole %safe %risk)] seam]
::    ==
::  ::  constrain cons
::  ++  knit
::    |=  [left=hail rite=hail]
::    ^-  [hail _seam]
::    =^  itch  seam  melt
::    =/  cole  (knit:ska hypo:(~(got by mist.seam) left) hypo:(~(got by mist.seam) rite)) 
::    ::  add itch with constraints
::    =.  mist.seam
::      %+  ~(put by mist.seam)
::        itch
::      [cole [%cons left rite]~]
::    [itch seam]
::  ::  fresh constraint variable
::  ++  melt
::    ^-  [hail _seam]
::    [hail.seam seam(+.hail .+(+.hail.seam))]
::  --
::  ::  sequential composition of laces
::  ++  land
::    |=(a=lace b=lace)
::    ?-  a
::      %boom  %boom
::      %risk  ?:(?=(%boom b) %boom %risk)
::      %safe  b
::    ==
::  ::  disjunctive combination of laces, for conditional
::  ++  lore
::    |=(a=lace b=lace)
::    ?:  ?&(?=(%safe a) ?=(%safe b))  %safe
::    ?:  ?&(?=(%boom a) ?=(%boom b))  %boom
::    %risk
::--

  
